*pattern.txt*   Nvim


                  VIM REFERENCE MANUAL    by Bram Moolenaar


Patterns and search commands                            *pattern-searches*

The very basics can be found in section |03.9| of the user manual.      A few more
explanations are in chapter 27 |usr_27.txt|.

                                                                          Type |gO| to see the table of contents.

==============================================================================
1. Search commands                              *search-commands*

*/*
/{pattern}[/]<CR>       Search forward for the [count]'th occurrence of
                        {pattern} |exclusive|.

/{pattern}/{offset}<CR> Search forward for the [count]'th occurrence of
                        {pattern} and go |{offset}| lines up or down.
                        |linewise|.

*/<CR>*
/<CR>                   Search forward for the [count]'th occurrence of the
                        latest used pattern |last-pattern| with latest used
                        |{offset}|.

//{offset}<CR>          Search forward for the [count]'th occurrence of the
                        latest used pattern |last-pattern| with new
                        |{offset}|.  If {offset} is empty no offset is used.

*?*
?{pattern}[?]<CR>       Search backward for the [count]'th previous
                        occurrence of {pattern} |exclusive|.

?{pattern}?{offset}<CR> Search backward for the [count]'th previous
                        occurrence of {pattern} and go |{offset}| lines up or
                        down |linewise|.

*?<CR>*
?<CR>                   Search backward for the [count]'th occurrence of the
                        latest used pattern |last-pattern| with latest used
                        |{offset}|.

??{offset}<CR>          Search backward for the [count]'th occurrence of the
                        latest used pattern |last-pattern| with new
                        |{offset}|.  If {offset} is empty no offset is used.

*n*
n                       Repeat the latest "/" or "?" [count] times.
                        If the cursor doesn't move the search is repeated with
                        count + 1.
                        |last-pattern|

*N*
N                       Repeat the latest "/" or "?" [count] times in
                        opposite direction. |last-pattern|

*star* *E348* *E349*
    *         Search forward for the [count]'th occurrence of the word nearest to the cursor.
    The word used for the search is the first of:
        1. the keyword under the cursor |'iskeyword'| 2. the first keyword after the cursor, in the current line
        3. the non-blank word under the cursor 4. the first non-blank word after the cursor, in the current line Only whole keywords are searched for,
    like with the command "/\<keyword\>".
    |exclusive| 'ignorecase' is used, 'smartcase' is not.


*#*
#                       Same as "*", but search backward.  The pound sign
                        (character 163) also works.  If the "#" key works as
                        backspace, try using "stty erase <BS>" before starting
                        Vim (<BS> is CTRL-H or a real backspace).

*gstar*
g*                      Like "*", but don't put "\<" and "\>" around the word.
                        This makes the search also find matches that are not a
                        whole word.

*g#*
g#                      Like "#", but don't put "\<" and "\>" around the word.
                        This makes the search also find matches that are not a
                        whole word.

*gd*
gd                      Goto local Declaration.  When the cursor is on a local
                        variable, this command will jump to its declaration.
                        First Vim searches for the start of the current
                        function, just like "[[".  If it is not found the
                        search stops in line 1.  If it is found, Vim goes back
                        until a blank line is found.  From this position Vim
                        searches for the keyword under the cursor, like with
                        "*", but lines that look like a comment are ignored
                        (see 'comments' option).
                        Note that this is not guaranteed to work, Vim does not
                        really check the syntax, it only searches for a match
                        with the keyword.  If included files also need to be
                        searched use the commands listed in |include-search|.
                        After this command |n| searches forward for the next
                        match (not backward).

*gD*
gD                      Goto global Declaration.  When the cursor is on a
                        global variable that is defined in the file, this
                        command will jump to its declaration.  This works just
                        like "gd", except that the search for the keyword
                        always starts in line 1.

*1gd*
1gd                     Like "gd", but ignore matches inside a {} block that
                        ends before the cursor position.

*1gD*
1gD                     Like "gD", but ignore matches inside a {} block that
                        ends before the cursor position.

*CTRL-C*
CTRL-C                  Interrupt current (search) command.
                        In Normal mode, any pending command is aborted.

*:noh* *:nohlsearch*
:noh[lsearch]           Stop the highlighting for the 'hlsearch' option.  It
                        is automatically turned back on when using a search
                        command, or setting the 'hlsearch' option.
                        This command doesn't work in an autocommand, because
                        the highlighting state is saved and restored when
                        executing autocommands |autocmd-searchpat|.
                        Same thing for when invoking a user function.

While typing the search pattern the current match will be shown if the
'incsearch' option is on.  Remember that you still have to finish the search
command with <CR> to actually position the cursor at the displayed match.  Or
use <Esc> to abandon the search.

All matches for the last used search pattern will be highlighted if you set
the 'hlsearch' option.  This can be suspended with the |:nohlsearch| command.

When 'shortmess' does not include the "S" flag, Vim will automatically show an
index, on which the cursor is. This can look like this:

  [1/5]         Cursor is on first of 5 matches.
  [1/>99]       Cursor is on first of more than 99 matches.
  [>99/>99]     Cursor is after 99 match of more than 99 matches.
  [?/??]        Unknown how many matches exists, generating the
                statistics was aborted because of search timeout.

Note: the count does not take offset into account.

When no match is found you get the error: *E486* Pattern not found
Note that for the |:global| command this behaves like a normal message, for Vi
compatibility.  For the |:s| command the "e" flag can be used to avoid the
error message |:s_flags|.

*search-offset* *{offset}*
These commands search for the specified pattern.  With "/" and "?" an
additional offset may be given.  There are two types of offsets: line offsets
and character offsets.

The offset gives the cursor position relative to the found match:
        [num]   [num] lines downwards, in column 1
        +[num]  [num] lines downwards, in column 1
        -[num]  [num] lines upwards, in column 1
        e[+num] [num] characters to the right of the end of the match
        e[-num] [num] characters to the left of the end of the match
        s[+num] [num] characters to the right of the start of the match
        s[-num] [num] characters to the left of the start of the match
        b[+num] [num] identical to s[+num] above (mnemonic: begin)
        b[-num] [num] identical to s[-num] above (mnemonic: begin)
        ;{pattern}      perform another search, see |//;|

If a '-' or '+' is given but [num] is omitted, a count of one will be used.
When including an offset with 'e', the search becomes inclusive (the
character the cursor lands on is included in operations).

Examples:

pattern                 cursor position
/test/+1                one line below "test", in column 1
/test/e                 on the last t of "test"
/test/s+2               on the 's' of "test"
/test/b-3               three characters before "test"

If one of these commands is used after an operator, the characters between
the cursor position before and after the search is affected.  However, if a
line offset is given, the whole lines between the two cursor positions are
affected.

An example of how to search for matches with a pattern and change the match
with another word:
        /foo<CR>        find "foo"
        c//e<CR>        change until end of match
        bar<Esc>        type replacement
        //<CR>          go to start of next match
        c//e<CR>        change until end of match
        beep<Esc>       type another replacement
                        etc.

*//;* *E386*
A very special offset is ';' followed by another search command.  For example:

   /test 1/;/test
   /test.*/+1;?ing?

The first one first finds the next occurrence of "test 1", and then the first
occurrence of "test" after that.

This is like executing two search commands after each other, except that:
- It can be used as a single motion command after an operator.
- The direction for a following "n" or "N" command comes from the first
  search command.
- When an error occurs the cursor is not moved at all.

*last-pattern*
The last used pattern and offset are remembered.  They can be used to repeat
the search, possibly in another direction or with another count.  Note that
two patterns are remembered: One for "normal" search commands and one for the
substitute command ":s".  Each time an empty pattern is given, the previously
used pattern is used.  However, if there is no previous search command, a
previous substitute pattern is used, if possible.

The 'magic' option sticks with the last used pattern.  If you change 'magic',
this will not change how the last used pattern will be interpreted.
The 'ignorecase' option does not do this.  When 'ignorecase' is changed, it
will result in the pattern to match other text.

All matches for the last used search pattern will be highlighted if you set
the 'hlsearch' option.

To clear the last used search pattern:
        :let @/ = ""
This will not set the pattern to an empty string, because that would match
everywhere.  The pattern is really cleared, like when starting Vim.

The search usually skips matches that don't move the cursor.  Whether the next
match is found at the next character or after the skipped match depends on the
'c' flag in 'cpoptions'.  See |cpo-c|.
           with 'c' flag:       "/..." advances 1 to 3 characters
        without 'c' flag:       "/..." advances 1 character
The unpredictability with the 'c' flag is caused by starting the search in the
first column, skipping matches until one is found past the cursor position.

When searching backwards, searching starts at the start of the line, using the
'c' flag in 'cpoptions' as described above.  Then the last match before the
cursor position is used.

In Vi the ":tag" command sets the last search pattern when the tag is searched
for.  In Vim this is not done, the previous search pattern is still remembered,
unless the 't' flag is present in 'cpoptions'.  The search pattern is always
put in the search history.

If the 'wrapscan' option is on (which is the default), searches wrap around
the end of the buffer.  If 'wrapscan' is not set, the backward search stops
at the beginning and the forward search stops at the end of the buffer.  If
'wrapscan' is set and the pattern was not found the error message "pattern
not found" is given, and the cursor will not be moved.  If 'wrapscan' is not
set the message becomes "search hit BOTTOM without match" when searching
forward, or "search hit TOP without match" when searching backward.  If
wrapscan is set and the search wraps around the end of the file the message
"search hit TOP, continuing at BOTTOM" or "search hit BOTTOM, continuing at
TOP" is given when searching backwards or forwards respectively.  This can be
switched off by setting the 's' flag in the 'shortmess' option.  The highlight
method 'w' is used for this message (default: standout).

*search-range*
You can limit the search command "/" to a certain range of lines by including
\%>l items.  For example, to match the word "limit" below line 199 and above
line 300:
        /\%>199l\%<300llimit
Also see |/\%>l|.

Another way is to use the ":substitute" command with the 'c' flag.      Example:
   :.,300s/Pattern//gc
This command will search from the cursor position until line 300 for
"Pattern".      At the match, you will be asked to type a character.  Type 'q' to
stop at this match, type 'n' to find the next match.

The "*", "#", "g*" and "g#" commands look for a word near the cursor in this
order, the first one that is found is used:
- The keyword currently under the cursor.
- The first keyword to the right of the cursor, in the same line.
- The WORD currently under the cursor.
- The first WORD to the right of the cursor, in the same line.
The keyword may only contain letters and characters in 'iskeyword'.
The WORD may contain any non-blanks (<Tab>s and/or <Space>s).
Note that if you type with ten fingers, the characters are easy to remember:
the "#" is under your left hand middle finger (search to the left and up) and
the "*" is under your right hand middle finger (search to the right and down).
(this depends on your keyboard layout though).

*E956*
In very rare cases a regular expression is used recursively.  This can happen
when executing a pattern takes a long time and when checking for messages on
channels a callback is invoked that also uses a pattern or an autocommand is
triggered.      In most cases this should be fine, but if a pattern is in use when
it's used again it fails.  Usually this means there is something wrong with
the pattern.

这个网站不错 https://learnbyexample.gitbooks.io/vim-reference/content/Regular_Expressions.html
                 https://learnbyexample.github.io/vim_reference/Regular-Expressions.html
==============================================================================
2. The definition of a pattern          *search-pattern* *pattern* *[pattern]*
*regular-expression* *regexp* *Pattern*
*E76* *E383* *E476*

For starters, read chapter 27 of the user manual |usr_27.txt|.

*/bar* */\bar* */pattern*
1. A pattern is one or more branches, separated by 💦\|💦.      It matches anything
   that matches one of the branches.  Example: "foo\|beep" matches "foo" and
   matches "beep".      If more than one branch matches, the first one is used.

   pattern ::=          branch
                or      branch \| branch \| branch
                etc.

*/branch* */\&*
                                                                           \& 由逻辑AND 发展过来吧
                                           少见, 可由\ze代替
2. A branch is one or more concats, separated by "\&".
It matches the last  concat, but only if all the preceding concats also match at the same  position.  Examples:
        "foobeep\&foo" matches "foo" in "foobeep" ,  but not in foo
        A\&B B必须是A的substring?
        💦foo\zebeep💦 也行

        ".*Peter\&.*Bob" matches in a line containing both "Peter" and "Bob"

   branch ::=           concat
                or      concat \& concat \& concat
                etc.

*/concat*
3. A concat is one or more pieces, concatenated.  It matches a match for the
   first piece, followed by a match for the second piece, etc.  Example:
   💦f[0-9]b💦, first matches "f", then a digit and then "b".

   concat  ::=          piece
                or      piece piece
                or      piece piece piece
                etc.

*/piece*
4. A piece is an atom, possibly followed by a multi, an indication of how many
   times the atom can be matched.  Example: "a*" matches any sequence of "a"
   characters: "", "a", "aa", etc.      See |/multi|.

   piece   ::=          atom
                or      atom  multi

*/atom*  pattern的最小单位
5. An atom can be one of a long list of items.

    Many atoms match one character in the text.
    It is often an ordinary character or a character class.

    Parentheses can be used to make a pattern into an atom.

   atom    ::=          ordinary-atom           |/ordinary-atom|
                or      \( pattern \)           |/\(|
                or      \%( pattern \)          |/\%(|
                or      \z( pattern \)          |/\z(|
                           The "\z(\)"  construct is only for syntax highlighting.

Character classes:

        1.  work for ascii and multibyte characters:

            \i      identifier character (see 'isident' option)     */\i*
            \I      like "\i", but excluding digits                 */\I*
            \k      keyword character (see 'iskeyword' option)      */\k*
            \K      like "\k", but excluding digits                 */\K*
            \f      file name character (see 'isfname' option)      */\f*
            \F      like "\f", but excluding digits                 */\F*
            \p      printable character (see 'isprint' option)      */\p*
            \P      like "\p", but excluding digits                 */\P*

        2. only match ASCII characters

*whitespace* *white-space*
            \s      whitespace character: <Space> and <Tab>         */\s*
            \S      non-whitespace character; opposite of \s        */\S*

                对比:
                [:space:]这个character class, 匹配 whitespace characters
                whitespace characters包括:
                        space, tab, CR,  NL, vertical tab, form feed


            \d      digit:                          [0-9]           */\d*
            \D      non-digit:                      [^0-9]          */\D*
            \x      hex digit:                      [0-9A-Fa-f]     */\x*
            \X      non-hex digit:                  [^0-9A-Fa-f]    */\X*
            \o      octal digit:                    [0-7]           */\o*
            \O      non-octal digit:                [^0-7]          */\O*
            \w      word character:                 [0-9A-Za-z_]    */\w*
            \W      non-word character:             [^0-9A-Za-z_]   */\W*
            \h      head of word character:         [A-Za-z_]       */\h*
            \H      non-head of word character:     [^A-Za-z_]      */\H*
            \a      alphabetic character:           [A-Za-z]        */\a*
            \A      non-alphabetic character:       [^A-Za-z]       */\A*
            \l      lowercase character:            [a-z]           */\l*
            \L      non-lowercase character:        [^a-z]          */\L*
            \u      uppercase character:            [A-Z]           */\u*
            \U      non-uppercase character:        [^A-Z]          */\U*

                NOTE: Using the atom is faster than the [] form.

                NOTE: 'ignorecase', "\c" and "\C" are not used by character classes.

            \_x     Where "x" is any of the characters below:
                    The character class with  end-of-line added
*/\_* *E63* */\_i* */\_I* */\_k* */\_K* */\_f* */\_F*
*/\_p* */\_P* */\_s* */\_S* */\_d* */\_D* */\_x* */\_X*
*/\_o* */\_O* */\_w* */\_W* */\_h* */\_H* */\_a* */\_A*
*/\_l* */\_L* */\_u* */\_U*
    (end of character classes)
    下面这些不是 character classes吧

    匹配单个特殊字符(控制字符?):

            \e      matches <Esc>                                   */\e*
            \t      matches <Tab>                                   */\t*
            \b      matches <BS>                                    */\b*
            \r      matches <CR>                                    */\r*
            \n      matches an end-of-line                          */\n*
                            When matching in a string instead of buffer text, a literal newline  character is matched.

    匹配某坨东西:
            ~       matches the last given substitute string        */~* */\~*
            \(\)    A pattern enclosed by escaped parentheses.      */\(* */\(\)* */\)*
                            E.g., "\(^a\)" matches 'a' at the start of a line.

    *E51* *E54* *E55* *E872* *E873*

    \1              Matches the same string that was matched by     */\1* *E65*
            the first sub-expression in \( and \).
            Example: "\([a-z]\).\1" matches "ata", "ehe", "tot", etc.
    \2              Like "\1", but uses second sub-expression,      */\2*
       ...                                                  */\3*
    \9              Like "\1", but uses ninth sub-expression.       */\9*
            Note: The numbering of groups is done based on which "\(" comes first
            in the pattern (going left to right), NOT based on what is matched
            first.

    \%(\)   A pattern enclosed by escaped parentheses.      */\%(\)* */\%(* *E53*
            Just like \(\), but without counting it as a sub-expression.  This allows using more groups and it's a little
            bit faster.

    x       A single character, with no special meaning, matches itself

    */\* */\\*
    \x      A backslash followed by a single character, with no special meaning,
            is reserved for future expansions

    []      (with 'nomagic': \[])           */[]* */\[]* */\_[]* */collection*
    \_[]
            A collection.
            This is a sequence of characters enclosed in square
            brackets.
            It matches any single character in the collection.

            Example         matches
            [xyz]           any 'x', 'y' or 'z'
            [a-zA-Z]$       any alphabetic character at the end of a line
            \c[a-z]$        same
            [А-яЁё]         Russian alphabet (with utf-8 and cp1251)

    */[\n]*

            With "\_" prepended the collection also includes the end-of-line.
            The same can be done by including "\n" in the collection.
            The end-of-line is also matched when the collection starts with "^"!
            Thus "\_[^ab]" matches the end-of-line and any character but "a" and "b".

            This makes it Vi compatible


            When the ']' is not there Vim will not give an error message but assume no collection is used.
            Useful to search for '['.  However,
            you do get *E769* for internal searching.
            And be aware that in a `:substitute` command the whole command becomes the pattern.
            E.g.
            ":s/[/x/" searches for "[/x" and replaces it with nothing.
            It does not search for "[" and replaces it with "x"!



            If the sequence begins with "^", it matches any single character NOT
            in the collection:
                "[^xyz]" matches anything but 'x', 'y' and 'z'.

            - If two characters in the sequence are separated by '-', this is
              shorthand for the full list of ASCII characters between them.
                    "[0-9]" matches any decimal digit.
              If the starting character exceeds  the ending character, e.g.
                  [c-a], *E944* occurs.

              Non-ASCII characters  can be used,
              but the character values must not be more than 256 apart  in the old regexp engine.
              For example, searching by [\u3000-\u4000]
              after setting re=1 emits a  *E945* error.
              Prepending \%#=2 will fix it.

            - A *character_class_expression* is evaluated to
              the set of characters belonging to that character class. (有的地方叫character sets)

	      The following 🔑character classes🔑  are supported:

                                              Name      Func(敲man 某函数来查)  Contents
                    *[:alnum:]*              [:alnum:]     isalnum                ASCII letters and digits
                    *[:alpha:]*              [:alpha:]     isalpha                ASCII letters
                    *[:cntrl:]*              [:cntrl:]     iscntrl                ASCII control characters
                    *[:graph:]*              [:graph:]     isgraph                ASCII printable characters,  excluding  space
                    *[:punct:]*              [:punct:]     ispunct                ASCII punctuation characters
                                                                                    printable character 刨掉 space 再刨掉 alphanumeric
                    *[:digit:]*              [:digit:]                            decimal digits '0' to '9'
                    *[:xdigit:]*             [:xdigit:]                             hexadecimal digits: 0-9, a-f, A-F

                    *[:lower:]*              [:lower:]     (1)                    lowercase letters (all letters when  'ignorecase' is used)
                    *[:print:]*              [:print:]     (2)                    printable characters 💛including💛 space
                    *[:upper:]*              [:upper:]     (3)                    uppercase letters (all letters when  'ignorecase' is used)

                    *[:tab:]*                [:tab:]                                        the <Tab> character
                    *[:blank:]*              [:blank:]                            space and tab
                    *[:space:]*              [:space:]                            whitespace characters:
                                                                                                      space, tab, CR,  NL, vertical tab, form feed
                    *[:return:]*             [:return:]                             the <CR> character
                    *[:escape:]*             [:escape:]                             the <Esc> character
                    *[:backspace:]*          [:backspace:]                          the <BS> character

                    *[:ident:]*              [:ident:]                              identifier character (same as "\i")
                    *[:keyword:]*            [:keyword:]                            keyword character (same as "\k")
                    *[:fname:]*              [:fname:]                              file name character (same as "\f")

                    The square brackets in character class expressions are additional to
                    the square brackets delimiting  a collection.
                    For example,
                    the following is a plausible pattern for a UNIX filename:
                            "[-./[:alnum:]_~]\+".
                    That is, a list of at least one character,      each of which is either
                            '-',
                            '.',
                            '/',
                            alphabetic,
                            numeric,
                            '_' or  '~'.

                    These items only work for 8-bit characters,
                    except [:lower:] and  [:upper:] also work for multibyte characters when using the new  regexp engine.
                    See |two-engines|.

                    In the future these items may  work for  multibyte characters.
                    For now,
                    to get all "alpha" characters you can use: [[:lower:][:upper:]].

                    The "Func" column shows what 🔑library function🔑 is used.
                    The  implementation depends on the system.
                    Otherwise:
                          (1) Uses islower() for ASCII and Vim builtin rules for other characters.
                          (2) Uses Vim builtin rules
                          (3) As with (1) but using isupper()

    */[[=* *[==]*
            - An equivalence class.  This means that characters are matched that
              have almost the same meaning, e.g., when ignoring accents.  This
              only works for Unicode, latin1 and latin9.  The form is:
                    [=a=]
    */[[.* *[..]*
            - A collation element.  This currently simply accepts a single
              character in the form:
                    [.a.]

    */\]*
        - To include a literal
        ']',
        '^',
        '-' or
        '\' in the collection,

        put a backslash before it:
        "[xyz\]]",
        "[\^xyz]",
        "[xy\-z]" and
        "[xyz\\]".

        (Note:
        POSIX does not support the use of a backslash this way).
        For ']' you can also make it the first character (following a possible "^"):
        "[]xyz]" or
        "[^]xyz]".

        For '-' you can also make it the first or
        last character:
        "[-xyz]",
        "[^-xyz]" or
        "[xyz-]".

        For '\' you can also let it be followed by
        any character that's not in "^]-\bdertnoUux".
        "[\xyz]" matches '\',
        'x',
        'y' and
        'z'.
        It's better to use "\\" though,

        future expansions may use other characters after '\'.
        - Omitting the trailing ] is not considered an error.
            "[]" works like "[]]",
            it matches the ']' character.
            - The following translations are accepted when the 'l' flag is not  included in 'cpoptions':
                    \e      <Esc>
                    \t      <Tab>
                    \r      <CR>    (NOT end-of-line!)
                    \b      <BS>
                    \n      line break, see above |/[\n]|

                    \d123   decimal number of character
                    \o40    octal number of character up to 0o377
                    \x20    hexadecimal number of character up to 0xff

                    \u20AC  hex. number of multibyte character up to 0xffff
                    \U1234  hex. number of multibyte character up to 0xffffffff

              🔑NOTE: The other backslash codes mentioned above do not work inside  []🔑!!!!!!!

            - Matching with a collection can be slow,
            because each character in the text has to be compared with each character in the collection.
            Use one of the other atoms above when possible.
            Example:
            "\d" is  much faster than "[0-9]" and
            matches the same characters.

             However,  the new |NFA| regexp engine deals with this better than the old one.

    */\%[]* *E69* *E70* *E369*

            To match the Ex command "function", where "fu" is required and
            "nction" is optional, this would work:
                    /\<fu\%[nction]\>
            The end-of-word atom "\>" is used to avoid matching "fu" in "full".

    \%[]    A sequence of optionally matched atoms.  This always matches.
            It matches as much of the list of atoms it contains as possible.  Thus
            it stops at the first atom that doesn't match.  For example:
                    /r\%[ead]
            matches "r", "re", "rea" or "read".  The longest that matches is used.
            It gets more complicated when the atoms are not 🔑ordinary characters🔑.
            You don't often have to use it, but it is possible.  Example:
                    /\<r\%[[eo]ad]\>
            Matches the words "r", "re", "ro", "rea", "roa", "read" and "road".
            There can be no \(\), \%(\) or \z(\) items inside the [] and \%[] does
            not nest.
            To include a "[" use "[[]" and for "]" use []]", e.g.,:
                    /index\%[[[]0[]]]
            matches "index" "index[", "index[0" and "index[0]".

    */\%d* */\%x* */\%o* */\%u* */\%U* *E678*

    \%d123  Matches the character specified with a decimal number.  Must be
            followed by a non-digit.
    \%o40   Matches the character specified with an octal number up to 0o377.
            Numbers below 0o40 must be followed by a non-octal digit or a
            non-digit.
    \%x2a   Matches the character specified with up to two hexadecimal characters.
    \%u20AC Matches the character specified with up to four hexadecimal
            characters.
    \%U1234abcd     Matches the character specified with up to eight hexadecimal
            characters, up to 0x7fffffff


==============================================================================
7. Ignoring case in a pattern                                   */ignorecase*

If the 'ignorecase' option is on, the case of normal letters is ignored.
'smartcase' can be set to ignore case when the pattern contains lowercase
letters only.
*/\c* */\C*
When "\c" appears anywhere in the pattern, the whole pattern is handled like
'ignorecase' is on.  The actual value of 'ignorecase' and 'smartcase' is
ignored.  "\C" does the opposite: Force matching case for the whole pattern.
{only Vim supports \c and \C}
Note that 'ignorecase', "\c" and "\C" are not used for the character classes.

Examples:
          pattern       'ignorecase'  'smartcase'       matches
            foo       off           -               foo
            foo       on            -               foo Foo FOO
            Foo       on            off             foo Foo FOO
            Foo       on            on                      Foo
            \cfoo     -             -               foo Foo FOO
            foo\C     -             -               foo

Technical detail:                               *NL-used-for-Nul*
        <Nul> characters in the file are stored as <NL> in memory.
        In the display they are shown as "^@".
        The translation is done when reading and
        writing files.
        To match a <Nul> with a search pattern you can just enter CTRL-@ or "CTRL-V 000".
        This is probably just what you expect.
        Internally the character is replaced with a <NL> in the search pattern.
        What is unusual is that typing CTRL-V CTRL-J also inserts a <NL>,
        thus also searches for a <Nul> in the file.

*CR-used-for-NL*
When 'fileformat' is "mac", <NL> characters in the file are stored as <CR>
characters internally.
        In the text they are shown as "^J".
        Otherwise this works similar to the usage of <NL> for a <Nul>.

When working with expression evaluation, a <NL> character in the pattern
matches a <NL> in the string.  The use of "\n" (backslash n) to match a <NL>
doesn't work there, it only works to match text in the buffer.

*pattern-multi-byte* *pattern-multibyte*
Patterns will also work with multibyte characters, mostly as you would
expect.  But invalid bytes may cause trouble, a pattern with an invalid byte
will probably never match.

==============================================================================
8. Composing characters                                 *patterns-composing*

*/\Z*
When "\Z" appears anywhere in the pattern,
all composing characters are ignored.
Thus only the base characters need to match,
the composing characters may be different and
the number of composing characters may differ.
Only relevant when 'encoding' is "utf-8".

Exception:
If the pattern starts with one or
more composing characters,
these must match.
*/\%C*
    Use "\%C" to skip any composing characters.
    For example,
    the pattern "a" does not match in "càt" (where the a has the composing character 0x0300),
    but
    "a\%C" does.
    Note that this does not match "cát" (where the á is character 0xe1,  it does not have a compositing character).
    It does match "cat" (where  the a is just an a).

when a composing character appears at the start of the pattern or after an
item that doesn't include the composing character, a match is found at any
character that includes this composing character.

When using a dot and a composing character, this works the same as the
composing character by itself, except that it doesn't matter what comes before
this.

The order of composing characters does not matter.      Also, the text may have
more composing characters than the pattern, it still matches.  But all
composing characters in the pattern must be found in the text.

Suppose B is a base character and x and y are composing characters:
        pattern         text            match
        Bxy             Bxy             yes (perfect match)
        Bxy             Byx             yes (order ignored)
        Bxy             By              no (x missing)
        Bxy             Bx              no (y missing)
        Bx              Bx              yes (perfect match)
        Bx              By              no (x missing)
        Bx              Bxy             yes (extra y ignored)
        Bx              Byx             yes (extra y ignored)

==============================================================================
9. Compare with Perl patterns                           *perl-patterns*

    Vim's regexes are most similar to Perl's,
    in terms of what you can do.
    The difference between them is mostly just notation;
    here's a summary of where
they differ:

Capability                      in Vimspeak     in Perlspeak
----------------------------------------------------------------
force case insensitivity        \c              (?i)
force case sensitivity          \C              (?-i)
backref-less grouping           \%(atom\)       (?:atom)
conservative quantifiers        \{-n,m}         *?, +?, ??, {}?
0-width match                   atom\@=         (?=atom)
0-width non-match               atom\@!         (?!atom)
0-width preceding match         atom\@<=        (?<=atom)
0-width preceding non-match     atom\@<!        (?<!atom)
match without retry             atom\@>         (?>atom)

Vim and Perl handle newline characters inside a string a bit differently:

In Perl, ^ and $ only match at the very beginning and end of the text,
by default, but you can set the 'm' flag, which lets them match at
embedded newlines as well.      You can also set the 's' flag, which causes
a . to match newlines as well.  (Both these flags can be changed inside
a pattern using the same syntax used for the i flag above, BTW.)

On the other hand, Vim's ^ and $ always match at embedded newlines, and
you get two separate atoms, \%^ and \%$, which only match at the very
start and end of the text, respectively.  Vim solves the second problem
by giving you the \_ "modifier":  put it in front of a . or a character
class, and they will match newlines as well.

Finally, these constructs are unique to Perl:
- execution of arbitrary code in the regex:  (?{perl code})
- conditional expressions:      (?(condition)true-expr|false-expr)

...and these are unique to Vim:
- changing the magic-ness of a pattern:  \v \V \m \M
   (very useful for avoiding backslashitis)
- sequence of optionally matching atoms:  \%[atoms]
- \& (which is to \| what "and" is to "or";  it forces several branches
   to match at one spot)
- matching lines/columns by number:  \%5l \%5c \%5v
- setting the start and end of the match:  \zs \ze

==============================================================================
10. Highlighting matches                                *match-highlight*

*:mat* *:match*
:mat[ch] {group} /{pattern}/

    Define a pattern to highlight in the current window.
    It will be highlighted with {group}.  Example:

                        :highlight MyGroup ctermbg=green guibg=green
                        :match MyGroup /TODO/

    Instead of // any character can be used to mark the start and
    end of the {pattern}.  Watch out for using special characters,
    such as '"' and
    '|'.
    {group} must exist at the moment this command is executed.
    The {group} highlighting still applies when a character is to be highlighted for 'hlsearch',
    as the 💛highlighting for matches💛 is given higher priority than that of 'hlsearch'.
    Syntax highlighting (see 'syntax') is also overruled by
    matches.

    Note that highlighting the last used search pattern with 'hlsearch' is used in all windows,
    while the pattern defined with ":match" only exists in the current window.
    It is kept when switching to another buffer.

    'ignorecase' does not apply,
    use |/\c| in the pattern to ignore case.
    Otherwise case is not ignored.

    'redrawtime' defines the maximum time searched for pattern matches.

    When matching end-of-line and
    Vim redraws only part of the display you may get unexpected results.
    That is because Vim looks for a match in the line where redrawing starts.

                Also see |matcharg()| and |getmatches()|. The former returns
                the highlight group and pattern of a previous |:match|
                command.  The latter returns a list with highlight groups and
                patterns defined by both |matchadd()| and |:match|.

                Highlighting matches using |:match| are limited to three
                matches (aside from |:match|, |:2match| and |:3match| are
                available). |matchadd()| does not have this limitation and in
                addition makes it possible to prioritize matches.

                Another example, which highlights all characters in virtual
                column 72 and more:
                        :highlight rightMargin term=bold ctermfg=blue guifg=blue
                        :match rightMargin /.\%>72v/
                To highlight all character that are in virtual column 7:
                        :highlight col8 ctermbg=grey guibg=grey
                        :match col8 /\%<8v.\%>7v/
                Note the use of two items to also match a character that
                occupies more than one virtual column, such as a TAB.

:mat[ch]
:mat[ch] none
                Clear a previously defined match pattern.


:2mat[ch] {group} /{pattern}/                                   *:2match*
:2mat[ch]
:2mat[ch] none
:3mat[ch] {group} /{pattern}/                                   *:3match*
:3mat[ch]
:3mat[ch] none
    Just like |:match| above,
    but set a separate match.
    Thus there can be three matches active at the same time.
    The match with the lowest number has priority if several match at the
    same position.
    The ":3match" command is used by
    the |matchparen| plugin.
    You are suggested to use ":match" for manual matching and
                ":2match" for another plugin.


 vim:tw=78:ts=8:noet:ft=help:norl:
